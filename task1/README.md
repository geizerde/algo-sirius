## Анализ сложности реверса

### Временная сложность

В процессе реверса метод `reverse` проходит по всем узлам списка один раз. 
В каждом цикле меняется направление ссылки текущего узла (путем переназначения ссылки `next`), 
и производится переход к следующему узлу.

В результате, временная сложность метода `reverse` определяется 
как \(O(n)\), так как сложность растет линейно с увеличением числа узлов.

### Затраты по памяти

Для реверса нам не нужно создавать дополнительные массивы или списки.
Все манипуляции выполняются с использованием фиксированного числа переменных:

- `prev` (предыдущий узел)
- `current` (текущий узел)
- `next_node` (временная переменная для хранения следующего узла)

Таким образом, независимо от количества узлов в списке,
метод `reverse` использует фиксированный объем памяти, 
то есть \(O(1)\), так как память не зависит от \(n\).
